install -> 在beforeCreate注入vuexInit
VuexInit在vue实例上创造出$store对象

module的父子通过Module实例上的children对象以及相关方法保持树的关系
形式如下
```
父module上
children : {
    path: 子module
}

```

module-collection真正做了分层的module，做了module的管理

store中的installModule将各个module放在store上（虽然有module，但store还是单一的）

resetStoreVM是核心，完成了store的存储，响应式，以及getters的实现（利用vue实例完成）
store是data，而getters是computed

如何做到修改必须通过commit mutation？ 源码的store._withCommit

平时可以注意的地方:vue.$store.(_mutations/_actions/getters)

没有命名空间时会注册在全局，那么模块之间的action和mutation重名带来的问题要注意吧（触发多个，改变多个store的值）
当然store是独立的

registerModule中如果使用了preserveState，似乎会忽略新的state，而是使用原来的，但是mutation，action正常注册
最后跟module关系就不大了，其实都是注册在全局的，module只是一种表示罢了



启发：
genericSubscribe这种事件订阅和解除的写法
接受多重类型的参数时，先用一个适配器化成一种然后再写逻辑，而不是if else
